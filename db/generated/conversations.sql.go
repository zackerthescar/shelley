// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversations.sql

package generated

import (
	"context"
)

const archiveConversation = `-- name: ArchiveConversation :one
UPDATE conversations
SET archived = TRUE, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned
`

func (q *Queries) ArchiveConversation(ctx context.Context, conversationID string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, archiveConversation, conversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const countArchivedConversations = `-- name: CountArchivedConversations :one
SELECT COUNT(*) FROM conversations WHERE archived = TRUE
`

func (q *Queries) CountArchivedConversations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countArchivedConversations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countConversations = `-- name: CountConversations :one
SELECT COUNT(*) FROM conversations WHERE archived = FALSE AND parent_conversation_id IS NULL
`

func (q *Queries) CountConversations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countConversations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations (conversation_id, slug, user_initiated, cwd, model)
VALUES (?, ?, ?, ?, ?)
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned
`

type CreateConversationParams struct {
	ConversationID string  `json:"conversation_id"`
	Slug           *string `json:"slug"`
	UserInitiated  bool    `json:"user_initiated"`
	Cwd            *string `json:"cwd"`
	Model          *string `json:"model"`
}

func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, createConversation,
		arg.ConversationID,
		arg.Slug,
		arg.UserInitiated,
		arg.Cwd,
		arg.Model,
	)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const createSubagentConversation = `-- name: CreateSubagentConversation :one
INSERT INTO conversations (conversation_id, slug, user_initiated, cwd, parent_conversation_id)
VALUES (?, ?, FALSE, ?, ?)
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned
`

type CreateSubagentConversationParams struct {
	ConversationID       string  `json:"conversation_id"`
	Slug                 *string `json:"slug"`
	Cwd                  *string `json:"cwd"`
	ParentConversationID *string `json:"parent_conversation_id"`
}

func (q *Queries) CreateSubagentConversation(ctx context.Context, arg CreateSubagentConversationParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, createSubagentConversation,
		arg.ConversationID,
		arg.Slug,
		arg.Cwd,
		arg.ParentConversationID,
	)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const deleteConversation = `-- name: DeleteConversation :exec
DELETE FROM conversations
WHERE conversation_id = ?
`

func (q *Queries) DeleteConversation(ctx context.Context, conversationID string) error {
	_, err := q.db.ExecContext(ctx, deleteConversation, conversationID)
	return err
}

const getConversation = `-- name: GetConversation :one
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned FROM conversations
WHERE conversation_id = ?
`

func (q *Queries) GetConversation(ctx context.Context, conversationID string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, getConversation, conversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const getConversationBySlug = `-- name: GetConversationBySlug :one
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned FROM conversations
WHERE slug = ?
`

func (q *Queries) GetConversationBySlug(ctx context.Context, slug *string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, getConversationBySlug, slug)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const getConversationBySlugAndParent = `-- name: GetConversationBySlugAndParent :one
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned FROM conversations
WHERE slug = ? AND parent_conversation_id = ?
`

type GetConversationBySlugAndParentParams struct {
	Slug                 *string `json:"slug"`
	ParentConversationID *string `json:"parent_conversation_id"`
}

func (q *Queries) GetConversationBySlugAndParent(ctx context.Context, arg GetConversationBySlugAndParentParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, getConversationBySlugAndParent, arg.Slug, arg.ParentConversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const getSubagents = `-- name: GetSubagents :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned FROM conversations
WHERE parent_conversation_id = ?
ORDER BY created_at ASC
`

func (q *Queries) GetSubagents(ctx context.Context, parentConversationID *string) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, getSubagents, parentConversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.ParentConversationID,
			&i.Model,
			&i.Pinned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArchivedConversations = `-- name: ListArchivedConversations :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned FROM conversations
WHERE archived = TRUE
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type ListArchivedConversationsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListArchivedConversations(ctx context.Context, arg ListArchivedConversationsParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, listArchivedConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.ParentConversationID,
			&i.Model,
			&i.Pinned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConversations = `-- name: ListConversations :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned FROM conversations
WHERE archived = FALSE AND parent_conversation_id IS NULL
ORDER BY pinned DESC, updated_at DESC
LIMIT ? OFFSET ?
`

type ListConversationsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListConversations(ctx context.Context, arg ListConversationsParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, listConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.ParentConversationID,
			&i.Model,
			&i.Pinned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pinConversation = `-- name: PinConversation :one
UPDATE conversations
SET pinned = TRUE, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned
`

func (q *Queries) PinConversation(ctx context.Context, conversationID string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, pinConversation, conversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const searchArchivedConversations = `-- name: SearchArchivedConversations :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned FROM conversations
WHERE slug LIKE '%' || ? || '%' AND archived = TRUE
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type SearchArchivedConversationsParams struct {
	Column1 *string `json:"column_1"`
	Limit   int64   `json:"limit"`
	Offset  int64   `json:"offset"`
}

func (q *Queries) SearchArchivedConversations(ctx context.Context, arg SearchArchivedConversationsParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, searchArchivedConversations, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.ParentConversationID,
			&i.Model,
			&i.Pinned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchConversations = `-- name: SearchConversations :many
SELECT conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned FROM conversations
WHERE slug LIKE '%' || ? || '%' AND archived = FALSE AND parent_conversation_id IS NULL
ORDER BY pinned DESC, updated_at DESC
LIMIT ? OFFSET ?
`

type SearchConversationsParams struct {
	Column1 *string `json:"column_1"`
	Limit   int64   `json:"limit"`
	Offset  int64   `json:"offset"`
}

func (q *Queries) SearchConversations(ctx context.Context, arg SearchConversationsParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, searchConversations, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.ParentConversationID,
			&i.Model,
			&i.Pinned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchConversationsWithMessages = `-- name: SearchConversationsWithMessages :many
SELECT DISTINCT c.conversation_id, c.slug, c.user_initiated, c.created_at, c.updated_at, c.cwd, c.archived, c.parent_conversation_id, c.model, c.pinned FROM conversations c
LEFT JOIN messages m ON c.conversation_id = m.conversation_id AND m.type IN ('user', 'agent')
WHERE c.archived = FALSE
  AND (
    c.slug LIKE '%' || ? || '%'
    OR json_extract(m.user_data, '$.text') LIKE '%' || ? || '%'
    OR m.llm_data LIKE '%' || ? || '%'
  )
ORDER BY c.pinned DESC, c.updated_at DESC
LIMIT ? OFFSET ?
`

type SearchConversationsWithMessagesParams struct {
	Column1 *string `json:"column_1"`
	Column2 *string `json:"column_2"`
	Column3 *string `json:"column_3"`
	Limit   int64   `json:"limit"`
	Offset  int64   `json:"offset"`
}

// Search conversations by slug OR message content (user messages and agent responses, not system prompts)
// Includes both top-level conversations and subagent conversations
func (q *Queries) SearchConversationsWithMessages(ctx context.Context, arg SearchConversationsWithMessagesParams) ([]Conversation, error) {
	rows, err := q.db.QueryContext(ctx, searchConversationsWithMessages,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ConversationID,
			&i.Slug,
			&i.UserInitiated,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Cwd,
			&i.Archived,
			&i.ParentConversationID,
			&i.Model,
			&i.Pinned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unarchiveConversation = `-- name: UnarchiveConversation :one
UPDATE conversations
SET archived = FALSE, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned
`

func (q *Queries) UnarchiveConversation(ctx context.Context, conversationID string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, unarchiveConversation, conversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const unpinConversation = `-- name: UnpinConversation :one
UPDATE conversations
SET pinned = FALSE, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned
`

func (q *Queries) UnpinConversation(ctx context.Context, conversationID string) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, unpinConversation, conversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const updateConversationCwd = `-- name: UpdateConversationCwd :one
UPDATE conversations
SET cwd = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned
`

type UpdateConversationCwdParams struct {
	Cwd            *string `json:"cwd"`
	ConversationID string  `json:"conversation_id"`
}

func (q *Queries) UpdateConversationCwd(ctx context.Context, arg UpdateConversationCwdParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, updateConversationCwd, arg.Cwd, arg.ConversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const updateConversationModel = `-- name: UpdateConversationModel :exec
UPDATE conversations
SET model = ?
WHERE conversation_id = ? AND model IS NULL
`

type UpdateConversationModelParams struct {
	Model          *string `json:"model"`
	ConversationID string  `json:"conversation_id"`
}

func (q *Queries) UpdateConversationModel(ctx context.Context, arg UpdateConversationModelParams) error {
	_, err := q.db.ExecContext(ctx, updateConversationModel, arg.Model, arg.ConversationID)
	return err
}

const updateConversationSlug = `-- name: UpdateConversationSlug :one
UPDATE conversations
SET slug = ?, updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
RETURNING conversation_id, slug, user_initiated, created_at, updated_at, cwd, archived, parent_conversation_id, model, pinned
`

type UpdateConversationSlugParams struct {
	Slug           *string `json:"slug"`
	ConversationID string  `json:"conversation_id"`
}

func (q *Queries) UpdateConversationSlug(ctx context.Context, arg UpdateConversationSlugParams) (Conversation, error) {
	row := q.db.QueryRowContext(ctx, updateConversationSlug, arg.Slug, arg.ConversationID)
	var i Conversation
	err := row.Scan(
		&i.ConversationID,
		&i.Slug,
		&i.UserInitiated,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cwd,
		&i.Archived,
		&i.ParentConversationID,
		&i.Model,
		&i.Pinned,
	)
	return i, err
}

const updateConversationTimestamp = `-- name: UpdateConversationTimestamp :exec
UPDATE conversations
SET updated_at = CURRENT_TIMESTAMP
WHERE conversation_id = ?
`

func (q *Queries) UpdateConversationTimestamp(ctx context.Context, conversationID string) error {
	_, err := q.db.ExecContext(ctx, updateConversationTimestamp, conversationID)
	return err
}
